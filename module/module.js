/**************************************************************************************************************************
 * ES6模块 module
 * 1.模块不是对象，而是通过export命令显示指定输出的代码，再通过import命令输入。
 * 2.两个命令 export 和 import
 * 2.自动采用严格模式。不管有没有再模块头部添加 “use strict”; 严格模式有以下限制：
 *     - 变量必须声明后再使用
 *     - 函数的参数不能有同名属性，否则报错
 *     - 不能使用with语句
 *     - 不能对只读属性赋值，否则报错
 *     - 不能使用前缀 0 表示八进制数，否则报错
 *     - 不能删除不可删除的属性，否则报错
 *     - 不能删除变量delete prop，会报错，只能删除属性delete global[prop]
 *     - eval不会在它的外层作用域引入变量
 *     - eval和arguments不能被重新赋值
 *     - arguments不会自动反映函数参数的变化
 *     - 不能使用arguments.callee
 *     - 不能使用arguments.caller
 *     - 禁止this指向全局对象
 *     - 不能使用fn.caller和fn.arguments获取函数调用的堆栈
 *     - 增加了保留字（比如protected、static和interface）
 *
 * 注意：使用关键字as时记住：先取后命名 因此重命名在as后面。格式：(导入||导出)的变量 as 重命名
 **************************************************************************************************************************/

/**************************************************************************************************************************
 * 3.export 命令 --- 输出
 *   一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取.
 *   如果希望外部能都读取模块内部的某个变量，就必选使用 export 关键字输出该变量。
 * 3.1 可以输出 变量 || 函数 || 类
 * 3.2 通常情况下 输出的变量就是本来的名字，但是可以使用 as 关键字重命名
 * 3.3 注意：export规定的是对外的接口，必须于模块内的变量建立一一对应关系。
 **************************************************************************************************************************/
// 输出变量
export var firstName = 'json';
export var lastName = 'str';

// 写法二 ( 优先考虑 ；可以再脚本末尾写，一眼清楚输出那些变量 )
var sex = 'female';
var age = 18;
export { sex, age };

function isBoolean(b) {
  if (typeof b === 'boolean' || b instanceof Boolean) {
    return true;
  }
  return false;
}

class Person {
  constructor() {
    this.name = 'V';
  }
}

// 输出函数 , 类(使用as关键字重命名)
export { isBoolean, Person as human };
// 输出函数 写法二
export function fun1() { }
// export fun1  // 报错

// 3.3 建立一一对应关系（错误输出）
// export 1 //报错 输出1 ，1只是值，不是接口
// export m = 1 // 报错。也是输出了1 /

/**************************************************************************************************************************
 * 4.import 命令 --- 加载（导入）
 *   编译时加载 || 静态加载 : 以下代码的实际是从a模块加载state,exists两个方法，其他方法不加载。
 *   异步加载
 *   详情请看 module.html
 * 4.1 import 接受大括号，指定从其他模块导入的变量名。变量名 == 导入的模块的对外接口名称 || 使用关键字 as 重命名
 * 4.2 模块的整体加载
 **************************************************************************************************************************/
// 从 index.js 文件中导入 state, exists 变量

import { state, exists } from './index.js';
import { state as s } from './index.js';
console.log(exists); // index.js文件的exists
console.log(s); //index.js文件的state


/**************************************************************************************************************************
 * 5.export default 命令
 *   为模块指定默认输出;一个模块只能有一个 export default 命令
 *   === 大意：其实就是相当于给一个输出的模块命名为 default 因此只能有一个,so 导入的时候不需要{}
 *   加载模块时，imort命令可以为该默认输出指定任意名字
 *   不能跟变量声明语句
 **************************************************************************************************************************/
var exportDefaultVal = 'im module.js文件的export default';
console.log(exportDefaultVal);
export default exportDefaultVal;
// export default var a = 1; //报错
// export default 42; 正确

// 导入的可以随便命名，这个时候导入的文本 *只有* index.js 文件的默认输出 的变量(其他的导出都不会看见)
import anyName from './index.js';
// console.log(anyName);

// 同时输入默认变量和其他接口
import anyName1, { otherVal } from './index.js';
// console.log(otherVal);

/**************************************************************************************************************************
 * 6.export 和 import 的复合写法
 **************************************************************************************************************************/
// 写成*一行*之后 foo, bar 实际上并没有导入这个模块,只是相当于作为一个中转接口,因此当前模块不能直接使用foo, bar
//  export { foo, bar } from 'my_module';
//  // 可以理解为
//  import { foo, bar } from 'my_module';
//  export { foo, bar };

/**************************************************************************************************************************
 * 7.跨模块常量
 * const 常量只在当前模块有效,因次若想设置跨模块的常量(即跨多个文件 || 一个值被多个模块共享 ),可采用该写法.
 **************************************************************************************************************************/
// 若常量非常多,可建立constants目录
// 查看constants下的文件
// 然后，将这些文件输出的常量，合并在constants/index.js里面。

// 导入的时候（查看constants/index.html）
// import {db, users} from './constants/index';

/**************************************************************************************************************************
 * 8.import() --- 动态加载模块
 *   接受参数于import语句相同
 *   返回promise对象。
 *   同步加载
 * 8.1 适用场景
 *     (1)按需加载 --- 需要的时候在加载
 *     (2)条件加载 --- 可以放在if代码块内。根据不同的情况，加载不同的模块
 *     (3)动态的模块路径 --- 允许模块路径动态生成。 import(f()).then(...);  f()函数返回一个模块路径
 **************************************************************************************************************************/
// 示例
// const main = document.querySelector('main');

// 格式; import(模块路径).then(加载成功返回的模块).catch()

// import(`./section-modules/${someVariable}.js`)
//   .then((module) => {
//     module.loadPageInto(main);
//   })
//   .catch((err) => {
//     main.textContent = err.message;
//   });

// (3) 动态的模块路径
//

/**************************************************************************************************************************
 * 9.module 的记载实现
 *   默认情况下，浏览器是同步加载 JavaScript 脚本 ；
 *   浏览器异步加载脚本: script标签需要添加defer或async属性 ；
 * 9.1 defer 与 async
 *     区别: 一句话，defer是“ 渲染完再执行”， async是“ 下载完就执行”。
 *     defer(推迟) --- 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；
 *     async(异步) --- 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
 *     另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。
 * 9.2 记载规则
 *   浏览器加载 ES6 模块，也使用<script>标签，但是要加入type="module"属性。浏览器对于带有type="module"的<script>，都是异步加载，
 **************************************************************************************************************************/



