<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>ES6</title>
</head>

<body>
  <div>
    <div>
      <h3>一.简介</h3>
      <p>
        Babel es6转码器:可以es6代码转化为ES5代码，从而在老版本得历览器执行。
      </p>
      <p>在项目中安装Babel命令： npm install --save-dev @babel/core</p>
      <h4>配置</h4>
      <p>
        babel 的配置文件为 .babelrc ;
        存放在下项目的更目录下。使用babel的第一步就是配置这个文件。
      </p>
      <p>该文件用来设置转码规则和插件，基本格式如下</p>
      { "presets":[], "plugins":[] }
    </div>

    <div>
      <h3>二 let和const命令</h3>
      <p>顶层对象的属性</p>
      <p>在es5中顶层对象定义的属性属于window属性。</p>
      <p>es6定义用var和function定义的顶层对象不变，还是属于window.</p>
      <p>但是用let和const和class定义的对象不属于window的属性</p>
      <p>1.在ES2020. 引入了globalThis作为顶层对象。指向全局环境的this</p>
    </div>

    <div>
      <h3>三 变量的解构赋值</h3>
    </div>
  </div>
  <script type="module">
    /**
       * 一  .babelrc的配置文件解释
       * presets : 设定转码规则；
       * 1. 最新转码规则
       * $npm install --save-dev @babel/preset-env
       * 2. react转码规则
       * $npm install --save-dev @babel/preset-react
       *
       * plugins ：设置插件
       *
       **/
  </script>

  <!-- 一, let 和 const -->
  <script>
    /*********************************************************************************************************************************
     * 二 let和const命令
     * 1.let
     * 1.1 let 命令声明变量，与var类似，但是let不会变量提升，必选在声明之后才能用。
     * 1.2 具有块级作用域，在let声明的代码块内才能用。 代码块内 {} 声明的都可以属于一个代码块。而且es6允许多个会计嵌套
     * 1.3 不允许重复声明
     ***********************************************************************************************************************************/
    {
      // console.log(b); // ->  Cannot access 'b' before initialization 不存在变量提升
      let a = 'zico';
      let b = 'v';
      console.log(a); // -> zico
    }
    // console.log(a) // -> 报错 a is not defined

    for (let i = 0; i < 2; i++) {
      console.log(i);
    }
    // console.log(i); // -> 报错 i is not defined

    /*********************************************************************************************************************************
     * i 的作用域不同
     * 在for设置循环变量内的i为父级作用域，在循环块内的i为单独的子集作用域。
     *********************************************************************************************************************************/
    for (let i = 0; i < 3; i++) {
      let i = 'abc';
      console.log(i); //输出三次abc
    }
    // abc
    // abc
    // abc

    // 2.块级作用域。多层嵌套
    {
      let a = 'donghae'; {
        let a = 'yancheng';
        console.log(a);
      }
      console.log(a);
    }

    {
      let a = 10;
      // let a = 1; // 报错 Identifier 'a' has already been declared
    }

    function func1(arg) {
      // let arg; // Identifier 'arg' has already been declared
    }
    func1(); // 报错

    function func2(arg) {
      {
        let arg;
      }
    }
    func2(); // 不报错

    /*********************************************************************************************************************************
     * 2. const
     * 2.1 声明只读的常量，常量不可修改。
     * 2.2 一般声明必须赋值，不然报错。
     * 2.3 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
     *********************************************************************************************************************************/
    {
      const a = 'guoguo';
      // a = "v" //报错 Assignment to constant variable.
      // const b;  // 报错 Missing initializer in const declaration
    }

    // 2.2常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
    {
      const foo = {};

      // 为 foo 添加一个属性，可以成功
      foo.prop = 123;
      console.log(foo.prop); // 123

      // 将 foo 指向另一个对象，就会报错
      //  foo = {}; // TypeError: "foo" is read-only  Assignment to constant variable.

      // 若想让对象冻结可以使用 Object.freeze
      const fooF = Object.freeze({});
    }

    /*********************************************************************************************************************************
     *  3.顶层对象属性
     * es5 在顶层定义的变量属于全局对象，即window对象，因此可以用window.访问。
     * 但是 let和const和class定义的对象不属于window的属性
     *
     *********************************************************************************************************************************/
    var g_a = '全局对象';
    console.log(g_a, window.g_a, this.g_a); // -> 全局对象 全局对象 全局对象

    let g_b = 'let定义顶层对象';
    console.log(g_b, window.g_b, this.g_b); // -> let定义顶层对象 undefined undefined
  </script>

  <!-- 二 变量的解构赋值 -->
  <script>
    /**************************************************************************************************************************
     * 1.数组的解构赋值
     * 本质上这种写法属于 “模式匹配”：只要等号两边的模式相同，左边的变量就会被赋予对应的值。
     * 如果解构不成功，变量的值就等于undefined
     * 事实上，只要某种数据结构具有Iterator 接口，都可以采用数组的结构赋值。
     * 1.1
     * 默认值。具备默认值的必要条件是 结构的值严格等于 undefined
     *
     * 区别：数组的解构赋值有顺序。而对象的没有。只需要对象内的属性名相同就可以
     **************************************************************************************************************************/
    {
      {
        let a = '1';
        let b = '2';
        // es6可以写成
        let [c, d] = ['1', '2'];
        console.log(c, d); //-> 1 2
      }

      {
        let [, , third] = ['foo', 'bar', 'baz'];
        console.log(third); // "baz"

        let [head, ...tail] = [1, 2, 3, 4];
        console.log(head, tail); // 1 ,  [2, 3, 4]  剩余运算符。

        let [x, y] = ['a'];
        console.log(x, y); // a undefined
      }

      // 默认值。具备默认值的必要条件是 结构的值严格等于 undefined
      {
        let [a = '1'] = [];
        console.log(a); // 1
        let [b = '2'] = [null];
        console.log(b); // null 解构的值不等于undefined。因此默认值不存在
      }
    }

    /**************************************************************************************************************************
     * 2.对象解构赋值
     * 与数组解构赋值类同
     * 本质是先找到同名属性(即匹配模式)，然后再赋值给对应的变量。真正被赋值的是后者。(先取出来后命名)
     * let { 取出来的相同属性的名称 ： 重新命名 } = { 相同属性的名称 ： "值"}
     *
     **************************************************************************************************************************/
    // 对象解构赋值的本质
    // let { 取出来的相同属性的名称 ： 重新命名 } = { 相同属性的名称 ： "值"}
    {
      {
        let {
          foo: baz
        } = {
          foo: 'aaa',
          bar: 'bbb',
        };
        console.log(baz); // "aaa"
        // console.log(foo); // foo is not defined

        // 上面的例子等价于
        // let { foo : foo } = { foo : "aaa"}  因为对象可以简写，因此可以简写为
        // let { foo } = { foo : "aaa" }
      }

      {
        let {
          a
        } = {
          a: '我是A',
        };
        console.log(a); //"我是A"

        let {
          b
        } = {
          c: '我是b',
        };

        console.log(b); //undefined  因为右边对象里面没有b属性
      }
    }

    /**************************************************************************************************************************
     * 3.字符串的解构赋值
     **************************************************************************************************************************/
    {
      let [a] = 'zico';
      console.log(a); //z

      // 字符串还有length属性
      let {
        length: len
      } = 'donghae';
      console.log(len); //7
    }

    /**************************************************************************************************************************
     * 4. 字符串/布尔值数值解构：若解构右边的不为数组/对象，先把右边的转化为对象。
     * 5. 函数的参数也可以解构赋值。模式参考数组/对象的解构赋值
     **************************************************************************************************************************/
    {
      let {
        toString: s
      } = true;
      console.log(s);
    }

    /**************************************************************************************************************************
     * 6.解构赋值的用途
     * 6.1 交换变量的值
     * 6.2 从函数返回多个值(取值就很方便)
     * 6.3 函数参数的定义/ 函数参数的默认值
     * 6.4 提取json数据
     * 6.5 遍历Map结构：任何部署了Iterator 接口的对象，都可以用for...of 循环遍历.Map 结构支持原生Interator 接口。
     * 6.6 输入模块的指定方法
     **************************************************************************************************************************/
    {
      // 6.1
      {
        let x = 1;
        let y = 2;
        [x, y] = [y, x];
        console.log(x, y);
      }

      {
        function fun1() {
          return {
            foo: '我是函数返回值foo',
            bar: '我是函数返回值bar',
          };
        }

        let {
          foo,
          bar
        } = fun1();
        console.log(foo, bar);
      }

      // 6.4
      {
        let jsonData = {
          id: 1,
          name: 'V',
          age: 18,
        };

        let {
          id,
          name
        } = jsonData;
        console.log(id, name);
      }

      // 6.5
      // 任何部署了Iterator 接口的对象，都可以用for...of 循环遍历.Map 结构支持原生Interator 接口。
      {
        const map = new Map();
        map.set('one', '我是V');
        map.set('two', '负责唱歌');

        for (let [key, val] of map) {
          console.log(`${key}.${val}`);
        }
      }

      // 6.6 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
      {
        // const {
        //   SourceMapConsumer,
        //   SourceNode
        // } = require("source-map");
      }
    }
  </script>

  <!-- 三 字符串的扩展 -->
  <script>
    /**************************************************************************************************************************
     * 1.字符串的遍历器接口
     * 使字符串可以被 for...of 循环遍历
     **************************************************************************************************************************/
    {
      let z = 'zzzzzziAco';
      for (const val of z) {
        console.log(val);
      }
    }

    /**************************************************************************************************************************
     * 2.模板字符串
     * 使用 `` 反引号包裹。使用变量时可以用 ${变量名} 在字符串中输入变量。
     * ${} 大括号内可以放入：变量，表达式，函数调用。大括号内的空格和换行都会保留
     *
     **************************************************************************************************************************/
    {
      let strBasic = '字符串';
      // 传统字符串拼接
      let str1 = '我是传统' + strBasic + '拼接';
      console.log(str1); // 我是传统字符串拼接

      let str2 = `我是ES6${strBasic}模板拼接`;
      console.log(str2); // 我是ES6字符串模板拼接

      let str3 = `1.大括号内表达式1+1= ${1 + 1}`;
      console.log(str3);

      let num = 5;
      let str4 = `2.大括号内表达式嵌入变量  ${num + 5}`;
      console.log(str4);

      let str5 = '我是html标签字符串';
      let strHtml = `<h3>${str5}</h3>`;
      console.log(strHtml);
    }
  </script>

  <!-- 四 字符串的新增方法 -->
  <script>
    /**************************************************************************************************************************
     * 1. 新增原生方法
     * 1.1 String.fromCodePoint() ----- 从unicode码点返回对象字符。
     * 1.2 String.raw() ----- 获取一个模板字符串的原始字符串的;比如说占位符（例如 ${foo}）会被处理为它所代表的其他字符串，而转义字符（例如\n）不会。
     *
     * 2. 新增实例方法
     * 2.1 codePointAt() ----- 处理4个字节存储的字符，返回一个字符的码点
     * 2.2 normalize() -----  用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。
     * 2.3 includes() ----- 返回布尔值，表示是否找到了参数字符串
     *     startsWith() ----- 返回布尔值，表示参数字符串是否存在字符串头部
     *     endsWith() ----- 返回布尔值，表示参数字符串是否存在字符串尾部
     *     这三个方法都支持第二个参数，表示开始搜索的位置
     * 2.4 repeat(n) ----- 返回新的字符串。表示将源字符串重复n次；
     *     如果参数为小数。则被向下取整
     *     如果repeat的参数是负数或者Infinity， 会报错。
     * 2.5 字符串补全; 参数1表示补全后的字符串最大长度，参数2表示补全的字符串。若参数1<原字符串长度。返回原字符串。
     *     padStart() ----- 在字符串开始部分补全
     *     padEnd() ----- 在字符串结尾部分补全
     * 2.6 消除字符串首尾空格/Tab键/换行符
     *     trimStart() ----- 别名 trimLeft()
     *     trimEnd() ----- 别名 trimRight()
     **************************************************************************************************************************/
    {
      let a = String.fromCodePoint(0xffff);
      console.log(a);

      let b = String.raw`Hi\\n`;
      a = "修改字符";
      let c = String.raw`${a}`;
      console.log(b); // 返回 "Hi\\n"
    }

    // 2.实例方法
    {
      let a = 'string';
      console.log(a.normalize());
    }

    // 查找字符串 includes()  startsWith()  endsWith()
    {
      let a = 'string';

      let res1 = a.includes('ng');
      console.log(res1);

      let res2 = a.startsWith('s');
      let res3 = a.startsWith('y');
      console.log(res2, res3);

      let res4 = a.endsWith('g');
      let res5 = a.endsWith('o');
      console.log(res4, res5);

      // 第二个参数
      let res6 = a.includes('t', 3);
      let res7 = a.includes('t', 1);
      console.log(res6, res7);

      let s = 'Hello world!';
      let res8 = s.startsWith('world', 6); // true
      console.log(res8);
    }

    // 2.4 repeat()
    {
      let str = 'V';
      let reStr = str.repeat(2);
      console.log('字符串repeat', reStr);

      // 如果参数为小数。则被向下取整
      console.log('A'.repeat(1.5));
    }

    // 2.5 padStart() padEnd()
    // @param 参数1表示补全后的字符串最大长度
    // @param 参数2表示补全的字符串
    {
      let str = 'donghae';
      let a = str.padStart(10, '帅');
      console.log(a); // 帅帅帅donghae

      let b = str.padEnd(10, '少年');
      console.log(b); // donghae少年少

      let c = str.padEnd(6, '88');
      // 若参数1<原字符串长度。返回原字符串。
      console.log(c); // donghae
    }

    // 字符串补全常见用途
    // 1.为数值补全指定位数
    // 2. 提示字符串格式
    {
      '12'.padStart(10, '0'); // "0000000012"
      '123456'.padStart(10, '0'); // "0000123456"
      '12'.padStart(10, 'YYYY-MM-DD'); // "YYYY-MM-12"
      '09-12'.padStart(10, 'YYYY-MM-DD'); // "YYYY-09-12"
    }

    // 2.6 trimStart() trimEnd() 返回新字符串，不会修改原字符串。
    {
      let str = '   aaa   ';
      console.log('trimStart', str, 'trimEnd');

      let a = str.trimStart();
      console.log('trimStart', a, 'trimEnd');
      console.log('trimStart', str.trimLeft(), 'trimEnd');

      let b = str.trimEnd();
      console.log('trimStart', b, 'trimEnd');
    }
  </script>

  <!-- 五 函数的扩展 -->
  <script>
    /**************************************************************************************************************************
     * 1.函数参数的默认值
     *   参数默认值的位置应该是函数的尾参数。
     *   参数变量是默认声明的，所有不能用let和const再次声明。因为也不能用同名参数。
     **************************************************************************************************************************/
    // 1.函数参数默认值
    {
      function fun1(x, y = 'V') {
        console.log(x, y);
      }

      fun1(); // undefined "V"
      fun1(1, 2); // 1 2

      let b = 10;

      function fun2(a = b + 2) {
        console.log(a);
      }

      fun2(); // 12
      b = 20;
      // 参数a的默认值时b+2;所以每次调用函数fun2的时候，都会重新计算b+2.
      fun2(); // 22

      // 与解构赋值结合使用
      function fun3({
        x,
        y = 5
      } = {}) {
        console.log(x, y);
      }

      fun3(); // undefined 5  弱国fun3函数内的参数对象没有默认值 ={} 则这个调用回报错
      fun3({}); // undefined 5

      fun3({
        x: 6,
      }); // 6,5

      fun3({
        x: 6,
        y: 6,
      }); // 6 6
    }

    /**************************************************************************************************************************
     * 2.rest 参数
     *   格式为： ...变量名。（改变量为一个数组，将多余的参数放入数组中）
     *   作用：用于获取函数的多余参数，因此不需要使用arguments对象，
     * 注意：rest之后不能再有其他参数。报错
     * 本质，将所有剩余的参数集合push到该数组变量里面，
     **************************************************************************************************************************/
    {
      function add(...vals) {
        let sum = 0;
        console.log(vals);
        for (let val of vals) {
          sum += val;
        }
        return sum;
      }

      let res = add(11, 2, 5);
      console.log(res); //18
    }

    /**************************************************************************************************************************
     * 3.name属性
     *   返回该函数的函数名
     *   将具名函数赋值给变量 --- 返回 具名函数的函数名
     *   将匿名函数赋值给变量 --- 返回 该变量名
     **************************************************************************************************************************/
    {
      function foo(params) { }
      let name = foo.name;
      console.log(name); // foo

      // 将具名函数赋值给变量
      let f1 = function basic_name(params) { };
      console.log(f1.name); // basic_name

      // 将匿名函数赋值给变量
      let f = function (params) { };
      console.log(f.name); // f
    }

    /**************************************************************************************************************************
     * 4.箭头函数
     *   格式：使用 "=>" 定义函数
     *   省略参数括号()的必要条件：只有一个参数的时候才能省略
     *   省略大括号{}：代码块的语句只有一条
     *   省略return 语句：代码块只有一句时
     *
     * 4.1 由于大括号被解释为代码块,因此若箭头函数直接返回一个对象的话,必须要在对象外边加上打括号 () .
     * 4.2 箭头函数注意点:
     *     (1).函数体内的this对象,总是指向定义时所在的对象. === this 指向不变 (因为箭头函数没有this)
     *     (2).不可以当作构造函数使用 === 不可以使用 new 命令 ---> 报错
     *     (3).不可使用arguments参数. 因为该对象再函数体内不存在.
     *     (4).不可以使用 yield命令 === 函数不能用作 Generator 函数。
     **************************************************************************************************************************/
    {
      let f = function (v) {
        return v;
      };
      // f 等同于 f_same
      let f_same = (v) => v;

      // f_same 的箭头函数省略了 参数括号，大括号和return语句
      // 如果参数不为一个,需要写参数括号
      // 如果代码块的语句多于一条 ---- 需要用括号{}将它们括起来 && 使用 return 语句
      let foo = (a, val) => {
        a.push(val);
        a.push('结束');
        return a;
      };

      let res = foo([], 1);
      console.log(res);

      // 若箭头函数直接返回对象 --- 必须用括号包裹 || 否则报错
      let resObj = () => ({
        id: 525,
      });
      console.log(resObj()); // {  id: 525 }

      // 若大括号直接包裹需要返回的对象
      let resObj2 = () => {
        {
          id: 525;
        }
      };
      console.log(resObj2()); // undefined

      let resObj3 = () => {
        return {};
      };
      console.log(resObj3()); // { }

      // 箭头函数this总是指向外层调用的this --- 因为箭头函数没有this.因此在箭头函数内使用this时,其实就是调用外层代码块的this.

      {
        function foo() {
          this.a = '1';
          let b = '2';
          setTimeout(() => {
            // console.log('id:', this.id); // id : 42
          }, 10);
        }

        var id = 21;

        foo.call({
          id: 42,
        });
      }
    }

    /**************************************************************************************************************************
     * 5.尾调用优化(tail call)
     *   函数的*最后一步是 return 调用另一个函数
     **************************************************************************************************************************/
    {
      // 尾调用
      function fn1() {
        return fn2();
      }
    }
  </script>

  <!-- 六 数组的扩展 -->
  <script>
    /**************************************************************************************************************************
     * 1.扩展运算符
     *   格式: ...
     *   含义: 将一个数组转化为逗号分隔的参数序列.
     * 1.1 应用场景
     *   (1)复制数组
     *   (2)合并数组
     *   (3)与解构赋值结合
     *   (4)实现了 Iterator 接口的对象 ; 任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。
     * 2.Array.from()
     *   用于将 类数组对象(即必须有length属性) || 可遍历的对象 --> 转化为真正的数组
     * 3.Array.of()
     *   用于将 一组值 --> 转化为数组 (总是返回参数构成的数组,若没有参数则返回空数组)
     **************************************************************************************************************************/
    {
      // 将一个数组转化为逗号分隔的参数序列
      let arr = [1, 2, 3];
      console.log(...arr); // 1 2 3

      let obj = {
        name: "v",
        age: 18
      };
      console.log({
        ...obj
      }, ...[obj]);
      // 都是可以正常返回obj对象

      // (1)复制数组
      {
        let a1 = [...arr]; // 写法一
        let [...a2] = a1; // 写法二

        arr[0] = 5;
        console.log(arr, a1, a2); // [5,2,3]  [1,2,3]  [1,2,3]
      }

      // (2)合并数组
      {
        const arr1 = ['a', 'b'];
        const arr2 = ['c'];
        const arr3 = ['d', 'e'];

        // ES5 的合并数组
        arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ]

        // ES6 的合并数组
        [...arr1, ...arr2, ...arr3]; // [ 'a', 'b', 'c', 'd', 'e' ]

        // 都属于浅拷贝
      }

      // (3)与解构赋值结合
      {
        const [first, ...rest] = [1, 2, 3, 4, 5];
        console.log(first); // 1
        console.log(rest); // [2, 3, 4, 5]
      }

      // (5)实现了 Iterator 接口的对象
      {
        let nodeList = document.querySelectorAll('div');
        let array = [...nodeList];
        console.log(nodeList, array);
      }

      // 3. Array.of() 总是返回参数构成的数组
      {
        Array.of(); // []
        Array.of(undefined); // [undefined]
        Array.of(3, 11, 8); // [3,11,8]
        Array.of(3); // [3]
        Array.of(3).length; // 1
      }
    }

    /**************************************************************************************************************************
     * 实例方法
     * 4.copyWithin() --- 将指定位置的成员复制到其他位置(覆盖原有成员),返回当前数组.
     **************************************************************************************************************************/
    {
      let arr = [1, 2, 3, 4, 5];

      // copyWithin() 原数组会改变
      // @param target(必须):从该位置开始替换数组,若为负值,表示倒数.
      // @param start(可选): 从该位置开始读取数据,默认0,若为负值,表示从末尾开始计算.
      // @param end(可选): 到该位置前停止读取数据,默认等于数组长度,若为负值,表示从末尾开始计算.
      let a1 = arr.copyWithin(3);
      console.log(arr, a1);

      let a2 = [1, 2, 3, 4, 5].copyWithin(1, 2); // 从位置1开始替换从2到5(数据长度)的数据
      console.log(a2);
    }

    /**************************************************************************************************************************
     * 实例方法
     * 5.1 find(function(){}) --- 找出第一个符合条件的数组成员 || undefined
     *     find(val,idx,arr) --- val:当前值; idx:当前下标;arr: 原数组
     * 5.2 findIndex(function(){}) --- 返回第一个符合的成员 || -1
     *
     **************************************************************************************************************************/
    {
      let arr = [1, 2, 3, 'v'];
      let res = arr.find((val) => val < 3);
      let res1 = arr.find((val) => val < 0);
      console.log(res, res1); // 1 undefined

      let res2 = arr.findIndex((val) => val < 0);
      console.log(res2); // -1

      // indexOf
      console.log(arr.indexOf('v'));
      console.log('string'.indexOf('g'));
    }

    /**************************************************************************************************************************
     * 6.fill()
     *   使用给定值,填充数组
     *   fill(val,start,end)
     *   参数说明:
     *   val:填充的数据; start:填充开始位置; end:填充结束位置;
     **************************************************************************************************************************/
    {
      let arr = [1, 2, 3];
      arr.fill(7);
      console.log(arr); // [7,7,7]

      // 用于数组初始化数据非常方便
      new Array(3).fill(7); // [7,7,7]

      // fill(val,start,end) 接受参数 end,不包含结束位置
      console.log([1, 2, 3, 4, 5].fill(6, 1, 3)); // [1,6,6,4,5]
    }

    /**************************************************************************************************************************
     * 7.实例方法 entries()，keys() 和 values() --- 用于遍历数组,返回一个遍历器对象,可以用for...of循环遍历.
     *   entries() --- 遍历键值对(条目)
     *   keys() --- 遍历键名
     *   values() --- 遍历键值
     **************************************************************************************************************************/
    {
      let arr = ['donghae', 'zico', 'V'];
      console.log(arr.values()); //返回 Array Interator 对象 (该类型对象可以用for...of循环遍历)

      for (const item of arr.entries()) {
        console.log(item); // [0,"donghae"]  [1,"zico"]  [2,"V"]
      }

      for (const item of arr.keys()) {
        console.log(item); // 0  1  2
      }

      for (const item of arr.values()) {
        console.log(item); // donghae zico V
      }
    }

    /**************************************************************************************************************************
     * 8.实例方法 includes("值",strat) --- strat(可选)默认0 开始位置
     *   返回布尔值;表示数组是否包含给定的值
     **************************************************************************************************************************/
    {
      let arr = ['donghae', 'zico', 'V'];
      console.log(arr.includes('v')); //false
      console.log(arr.includes('V')); //true

      console.log(arr.includes('V', -6)); //true
      console.log(arr.includes('V', -2)); //true
    }

    /**************************************************************************************************************************
     * 9.flat(),flatMap()
     * (1) flat()
     *    flat(num) --- 将数组拉平(二维数组变为一维数组),原数组无影响
     *    num 可选,拉平的层数; 默认1 --> 只拉平一层; 因此想要拉平多层,可填写num值为层级
     *    Infinity 关键字 --- 不清楚数组的具体层数,单数需要拉平所有,设置参数为 Infinity
     * (2) flatMap(回调函数)
     *     回调函数相当于对数组内的每一个值执行 Array.prototype.map(),然后返回的值组成的数组执行 flat().
           只能展开一层数组
     **************************************************************************************************************************/
    {
      let arr = [1, 2, [4, 5]];
      let res = arr.flat();
      console.log(arr, res); //[1, 2, [4, 5]]  [1,2,4,5]

      let res1 = [1, [2, [5]]].flat(2);
      console.log(res1); //[1,2,5]

      // Infinity 关键字
      let res2 = [1, [2, [5, [7, [10]]]]].flat(Infinity);
      console.log(res2); // [1,2,5,7,10]

      // res3 ,res3 返回的是一样的
      let res3 = [2, 3, 4].flatMap((x) => x * 2);
      console.log(res3); // [4,6,8]

      let res4 = [2, 3, 4].flatMap((x) => [x * 2]);
      console.log(res4); // [4,6,8]   返回过程 [[4],[6],[8]]  ->  [4,6,8]
    }

    /**************************************************************************************************************************
     * 10.数组的空位---数组的某一个位置没有任何值
     * 由于空位的处理规则不统一,所以建议避免出现空位
     **************************************************************************************************************************/
    {
      console.log(Array(3)); // [, , ,]   [empty × 3]
    }
  </script>

  <!-- 七 对象的扩展;查看 Object文件 -->
  <script></script>

  <!-- 八 module 的语法;查看 module文件夹 -->
</body>

</html>